/**
 * Game URL Service
 * Fetches and manages direct URLs to betting sites for specific games
 */

import { firebaseService } from '../src/atomic/organisms/firebaseService';
import 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { analyticsService } from './analyticsService';
import { firestore } from '../config/firebase';
import { collection, doc, getDoc, getDocs, query, where, writeBatch, Timestamp } from 'firebase/firestore';

// Define types for game URLs
export interface GameUrl {
  gameId: string;
  sportType: string;
  leagueId: string;
  homeTeamId: string;
  awayTeamId: string;
  startTime: Date;
  fanduelUrl: string;
  lastUpdated: Date;
  isActive: boolean;
}

// Define supported sports APIs
export enum SportsApiType {
  ODDS_API = 'odds_api',
  SPORTS_RADAR = 'sports_radar',
  ESPN_API = 'espn_api',
}

// Define supported betting sites
export enum BettingSite {
  FANDUEL = 'fanduel',
  DRAFTKINGS = 'draftkings',
  BETMGM = 'betmgm',
  CAESARS = 'caesars',
}

// Storage keys
const STORAGE_KEYS = {
  GAME_URLS_CACHE: 'game_urls_cache',
  LAST_FETCH_TIME: 'game_urls_last_fetch',
};

// Firestore collection names
const COLLECTIONS = {
  GAME_URLS: 'gameUrls',
  API_KEYS: 'apiKeys',
};

/**
 * Game URL Service
 * Fetches and manages direct URLs to betting sites for specific games
 */
class GameUrlService {
  private cache: Record<string, GameUrl> = {};
  private lastFetchTime: Date | null = null;
  private fetchPromise: Promise<void> | null = null;
  private apiKeys: Record<SportsApiType, string> = {
    [SportsApiType.ODDS_API]: '',
    [SportsApiType.SPORTS_RADAR]: '',
    [SportsApiType.ESPN_API]: '',
  };
  
  /**
   * Initialize the service
   */
  async initialize(): Promise<void> {
    try {
      // Load cache from storage
      await this.loadCache();
      
      // Load API keys from Firestore
      await this.loadApiKeys();
      
      // Fetch latest game URLs if cache is stale
      if (this.isCacheStale()) {
        this.fetchPromise = this.fetchGameUrls();
      }
    } catch (error) {
      console.error('Error initializing GameUrlService:', error);
    }
  }
  
  /**
   * Load cache from storage
   */
  private async loadCache(): Promise<void> {
    try {
      // Load cache
      const cacheJson = await AsyncStorage.getItem(STORAGE_KEYS.GAME_URLS_CACHE);
      if (cacheJson) {
        const parsedCache = JSON.parse(cacheJson);
        
        // Convert string dates to Date objects
        Object.values(parsedCache).forEach((gameUrl: any) => {
          gameUrl.startTime = new Date(gameUrl.startTime);
          gameUrl.lastUpdated = new Date(gameUrl.lastUpdated);
        });
        
        this.cache = parsedCache;
      }
      
      // Load last fetch time
      const lastFetchTimeStr = await AsyncStorage.getItem(STORAGE_KEYS.LAST_FETCH_TIME);
      if (lastFetchTimeStr) {
        this.lastFetchTime = new Date(lastFetchTimeStr);
      }
    } catch (error) {
      console.error('Error loading game URL cache:', error);
    }
  }
  
  /**
   * Save cache to storage
   */
  private async saveCache(): Promise<void> {
    try {
      await AsyncStorage.setItem(STORAGE_KEYS.GAME_URLS_CACHE, JSON.stringify(this.cache));
      
      if (this.lastFetchTime) {
        await AsyncStorage.setItem(STORAGE_KEYS.LAST_FETCH_TIME, this.lastFetchTime.toISOString());
      }
    } catch (error) {
      console.error('Error saving game URL cache:', error);
    }
  }
  
  /**
   * Load API keys from Firestore
   */
  private async loadApiKeys(): Promise<void> {
    try {
      if (!firestore) {
        console.warn('Firestore not initialized');
        return;
      }
      
      const apiKeysDocRef = firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.doc(firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.collection(firestore, COLLECTIONS.API_KEYS), 'sports');
      const apiKeysDoc = await getDoc(apiKeysDocRef);
      
      if (apiKeysDoc.exists()) {
        const data = apiKeysDoc.data();
        if (data) {
          Object.keys(this.apiKeys).forEach(key => {
            if (data[key]) {
              this.apiKeys[key as SportsApiType] = data[key];
            }
          });
        }
      }
    } catch (error) {
      console.error('Error loading API keys:', error);
    }
  }
  
  /**
   * Check if cache is stale (older than 6 hours)
   */
  private isCacheStale(): boolean {
    if (!this.lastFetchTime) {
      return true;
    }
    
    const sixHoursAgo = new Date();
    sixHoursAgo.setHours(sixHoursAgo.getHours() - 6);
    
    return this.lastFetchTime < sixHoursAgo;
  }
  
  /**
   * Fetch game URLs from sports APIs and store in Firestore
   */
  private async fetchGameUrls(): Promise<void> {
    try {
      // Set last fetch time
      this.lastFetchTime = new Date();
      
      // Fetch from multiple APIs in parallel
      const [oddsApiUrls, sportsRadarUrls, espnApiUrls] = await Promise.all([
        this.fetchFromOddsApi(),
        this.fetchFromSportsRadar(),
        this.fetchFromEspnApi(),
      ]);
      
      // Merge results
      const allUrls = [...oddsApiUrls, ...sportsRadarUrls, ...espnApiUrls];
      
      // Update cache
      allUrls.forEach(gameUrl => {
        this.cache[gameUrl.gameId] = gameUrl;
      });
      
      // Save to storage
      await this.saveCache();
      
      // Save to Firestore
      await this.saveToFirestore(allUrls);
      
      // Track success
      analyticsService.trackEvent('game_urls_fetched', {
        count: allUrls.length,
        platform: Platform.OS,
        timestamp: Date.now(),
      });
    } catch (error) {
      console.error('Error fetching game URLs:', error);
      
      // Track error
      analyticsService.trackError(error as Error, {
        action: 'fetch_game_urls',
        platform: Platform.OS,
      });
    } finally {
      this.fetchPromise = null;
    }
  }
  
  /**
   * Fetch game URLs from The Odds API
   */
  private async fetchFromOddsApi(): Promise<GameUrl[]> {
    if (!this.apiKeys[SportsApiType.ODDS_API]) {
      return [];
    }
    
    try {
      // Example URL: https://api.the-odds-api.com/v4/sports/basketball_nba/odds/?apiKey=YOUR_API_KEY&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel
      const apiKey = this.apiKeys[SportsApiType.ODDS_API];
      const sports = ['basketball_nba', 'basketball_ncaab', 'football_nfl', 'baseball_mlb'];
      const bookmakers = ['fanduel'];
      
      const allResults: GameUrl[] = [];
      
      // Fetch for each sport
      for (const sport of sports) {
        const response = await fetch(
          `https://api.the-odds-api.com/v4/sports/${sport}/odds/?apiKey=${apiKey}&regions=us&markets=h2h&oddsFormat=american&bookmakers=${bookmakers.join(',')}`
        );
        
        if (!response.ok) {
          throw new Error(`The Odds API error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Process results
        data.forEach((game: any) => {
          // Extract FanDuel URL from bookmakers
          const fanduelBookmaker = game.bookmakers.find((b: any) => b.key === 'fanduel');
          if (fanduelBookmaker) {
            // In a real implementation, the FanDuel URL would be provided by the API
            // For now, we'll construct a URL based on the game ID
            const sportType = sport.split('_')[0];
            const leagueId = sport.split('_')[1];
            
            const gameUrl: GameUrl = {
              gameId: game.id,
              sportType,
              leagueId,
              homeTeamId: game.home_team.replace(/\\s+/g, '-').toLowerCase(),
              awayTeamId: game.away_team.replace(/\\s+/g, '-').toLowerCase(),
              startTime: new Date(game.commence_time),
              fanduelUrl: `https://sportsbook.fanduel.com/${sportType}/${leagueId}/${game.id}`,
              lastUpdated: new Date(),
              isActive: new Date(game.commence_time) > new Date(),
            };
            
            allResults.push(gameUrl);
          }
        });
      }
      
      return allResults;
    } catch (error) {
      console.error('Error fetching from The Odds API:', error);
      return [];
    }
  }
  
  /**
   * Fetch game URLs from Sports Radar API
   */
  private async fetchFromSportsRadar(): Promise<GameUrl[]> {
    // In a real implementation, this would fetch from the Sports Radar API
    // For now, we'll return an empty array
    return [];
  }
  
  /**
   * Fetch game URLs from ESPN API
   */
  private async fetchFromEspnApi(): Promise<GameUrl[]> {
    // In a real implementation, this would fetch from the ESPN API
    // For now, we'll return an empty array
    return [];
  }
  
  /**
   * Save game URLs to Firestore
   */
  private async saveToFirestore(gameUrls: GameUrl[]): Promise<void> {
    try {
      if (!firestore) {
        console.warn('Firestore not initialized');
        return;
      }
      
      const firestoreInstance = firestore;
      const batch = writeBatch(firestoreInstance);
      
      // Add each game URL to batch
      gameUrls.forEach(gameUrl => {
        const gameUrlsCollection = firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.collection(firestoreInstance, COLLECTIONS.GAME_URLS);
        const docRef = firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.doc(gameUrlsCollection, gameUrl.gameId);
        batch.set(docRef, {
          ...gameUrl,
          startTime: Timestamp.fromDate(gameUrl.startTime),
          lastUpdated: Timestamp.fromDate(gameUrl.lastUpdated),
        });
      });
      
      // Commit batch
      await batch.commit();
    } catch (error) {
      console.error('Error saving game URLs to Firestore:', error);
    }
  }
  
  /**
   * Get game URL for a specific game
   * @param gameId Game ID
   * @param bettingSite Betting site to get URL for
   * @returns Game URL or null if not found
   */
  async getGameUrl(gameId: string, bettingSite: BettingSite = BettingSite.FANDUEL): Promise<string | null> {
    // Wait for any pending fetch to complete
    if (this.fetchPromise) {
      await this.fetchPromise;
    }
    
    // Check if we need to refresh the cache
    if (this.isCacheStale() && !this.fetchPromise) {
      this.fetchPromise = this.fetchGameUrls();
      await this.fetchPromise;
    }
    
    // Check cache
    const gameUrl = this.cache[gameId];
    if (gameUrl) {
      // Track usage
      analyticsService.trackEvent('game_url_used', {
        gameId,
        bettingSite,
        platform: Platform.OS,
        timestamp: Date.now(),
      });
      
      // Return URL based on betting site
      switch (bettingSite) {
        case BettingSite.FANDUEL:
          return gameUrl.fanduelUrl;
        default:
          return gameUrl.fanduelUrl; // Default to FanDuel
      }
    }
    
    // If not in cache, try to fetch from Firestore
    try {
      if (!firestore) {
        console.warn('Firestore not initialized');
        return null;
      }
      
      const firestoreInstance = firestore;
      const gameUrlsCollection = firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.collection(firestoreInstance, COLLECTIONS.GAME_URLS);
      const gameDocRef = firebaseService.firestore.firebaseService.firestore.firebaseService.firestore.doc(gameUrlsCollection, gameId);
      const gameDoc = await getDoc(gameDocRef);
      
      if (gameDoc.exists()) {
        const data = gameDoc.data() as any;
        
        // Convert Firestore timestamps to Date objects
        const gameUrl: GameUrl = {
          ...data,
          startTime: data.startTime.toDate(),
          lastUpdated: data.lastUpdated.toDate(),
        };
        
        // Add to cache
        this.cache[gameId] = gameUrl;
        
        // Track usage
        analyticsService.trackEvent('game_url_used', {
          gameId,
          bettingSite,
          platform: Platform.OS,
          timestamp: Date.now(),
        });
        
        // Return URL based on betting site
        switch (bettingSite) {
          case BettingSite.FANDUEL:
            return gameUrl.fanduelUrl;
          default:
            return gameUrl.fanduelUrl; // Default to FanDuel
        }
      }
    } catch (error) {
      console.error('Error fetching game URL from Firestore:', error);
    }
    
    return null;
  }
  
  /**
   * Get game URLs for a specific sport and league
   * @param sportType Sport type (e.g., 'basketball', 'football')
   * @param leagueId League ID (e.g., 'nba', 'ncaab')
   * @param activeOnly Only return active games
   * @returns Array of game URLs
   */
  getGameUrlsForLeague(sportType: string, leagueId: string, activeOnly: boolean = true): GameUrl[] {
    return Object.values(this.cache).filter(gameUrl => 
      gameUrl.sportType === sportType && 
      gameUrl.leagueId === leagueId &&
      (!activeOnly || gameUrl.isActive)
    );
  }
  
  /**
   * Get game URLs for a specific team
   * @param teamId Team ID
   * @param activeOnly Only return active games
   * @returns Array of game URLs
   */
  getGameUrlsForTeam(teamId: string, activeOnly: boolean = true): GameUrl[] {
    return Object.values(this.cache).filter(gameUrl => 
      (gameUrl.homeTeamId === teamId || gameUrl.awayTeamId === teamId) &&
      (!activeOnly || gameUrl.isActive)
    );
  }
  
  /**
   * Force refresh of game URLs
   */
  async forceRefresh(): Promise<void> {
    if (this.fetchPromise) {
      await this.fetchPromise;
    }
    
    this.fetchPromise = this.fetchGameUrls();
    await this.fetchPromise;
  }
}

export const gameUrlService = new GameUrlService();