#!/usr/bin/env node

/**
 * Vulnerability Scanning Script
 *
 * This script performs comprehensive vulnerability scanning for the AI Sports Edge application.
 * It checks for dependencies with known vulnerabilities, insecure configurations, and common security issues.
 */

const chalk = require('chalk');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Results object
const results = {
  summary: {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
    total: 0,
  },
  scans: {},
  timestamp: new Date().toISOString(),
};

/**
 * Run a command and return the output
 * @param {String} command - Command to run
 * @param {Boolean} silent - Whether to suppress output
 * @returns {String} Command output
 */
const runCommand = (command, silent = false) => {
  try {
    return execSync(command, {
      encoding: 'utf8',
      stdio: silent ? 'pipe' : 'inherit',
    });
  } catch (error) {
    if (!silent) {
      console.error(chalk.red(`Error running command: ${command}`));
      console.error(error.message);
    }
    return error.stdout || '';
  }
};

/**
 * Update the summary with new vulnerabilities
 * @param {Object} vulns - Vulnerability counts by severity
 */
const updateSummary = vulns => {
  results.summary.critical += vulns.critical || 0;
  results.summary.high += vulns.high || 0;
  results.summary.medium += vulns.medium || 0;
  results.summary.low += vulns.low || 0;
  results.summary.info += vulns.info || 0;
  results.summary.total +=
    (vulns.critical || 0) +
    (vulns.high || 0) +
    (vulns.medium || 0) +
    (vulns.low || 0) +
    (vulns.info || 0);
};

/**
 * Run npm audit to check for vulnerable dependencies
 */
const runNpmAudit = async () => {
  console.log(chalk.blue('Running npm audit...'));

  try {
    const output = runCommand('npm audit --json', true);
    const auditResults = JSON.parse(output);

    // Extract vulnerability counts
    const vulns = {
      critical: auditResults.metadata?.vulnerabilities?.critical || 0,
      high: auditResults.metadata?.vulnerabilities?.high || 0,
      medium: auditResults.metadata?.vulnerabilities?.moderate || 0,
      low: auditResults.metadata?.vulnerabilities?.low || 0,
      info: 0,
    };

    // Update summary
    updateSummary(vulns);

    // Store results
    results.scans.npmAudit = {
      vulnerabilities: vulns,
      details: auditResults.advisories || {},
    };

    // Display results
    if (vulns.critical > 0 || vulns.high > 0) {
      console.log(
        chalk.red(
          `npm audit found ${vulns.critical} critical and ${vulns.high} high severity vulnerabilities`
        )
      );
    } else if (vulns.medium > 0) {
      console.log(
        chalk.yellow(`npm audit found ${vulns.medium} moderate severity vulnerabilities`)
      );
    } else {
      console.log(chalk.green('npm audit completed with no high or critical vulnerabilities'));
    }
  } catch (error) {
    console.log(chalk.red(`Error running npm audit: ${error.message}`));
    results.scans.npmAudit = {
      error: error.message,
    };
  }
};

/**
 * Check for insecure configurations
 */
const checkInsecureConfigs = async () => {
  console.log(chalk.blue('Checking for insecure configurations...'));

  try {
    const issues = [];

    // Check for .env files
    if (fs.existsSync('.env')) {
      const envContent = fs.readFileSync('.env', 'utf8');

      // Check for sensitive information
      const sensitivePatterns = [
        { pattern: /password/i, name: 'Password' },
        { pattern: /secret/i, name: 'Secret' },
        { pattern: /key/i, name: 'API Key' },
        { pattern: /token/i, name: 'Token' },
      ];

      sensitivePatterns.forEach(({ pattern, name }) => {
        if (pattern.test(envContent)) {
          issues.push({
            file: '.env',
            severity: 'high',
            message: `Possible ${name} found in .env file`,
          });
        }
      });
    }

    // Check for insecure package.json configurations
    if (fs.existsSync('package.json')) {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));

      // Check for outdated Node.js engine
      if (packageJson.engines && packageJson.engines.node) {
        const nodeVersion = packageJson.engines.node.replace(/[^\d.]/g, '');
        const majorVersion = parseInt(nodeVersion.split('.')[0], 10);

        if (majorVersion < 14) {
          issues.push({
            file: 'package.json',
            severity: 'medium',
            message: `Outdated Node.js engine: ${packageJson.engines.node}`,
          });
        }
      }

      // Check for insecure dependencies
      const insecureDeps = ['eval', 'unsafe-eval', 'unsafe-perm'];

      const allDeps = {
        ...(packageJson.dependencies || {}),
        ...(packageJson.devDependencies || {}),
      };

      Object.keys(allDeps).forEach(dep => {
        if (insecureDeps.includes(dep)) {
          issues.push({
            file: 'package.json',
            severity: 'high',
            message: `Insecure dependency: ${dep}`,
          });
        }
      });
    }

    // Check for insecure webpack configurations
    const webpackConfigFiles = ['webpack.config.js', 'webpack.dev.js', 'webpack.prod.js'];

    webpackConfigFiles.forEach(configFile => {
      if (fs.existsSync(configFile)) {
        const configContent = fs.readFileSync(configFile, 'utf8');

        // Check for eval in devtool
        if (/devtool.*eval/.test(configContent)) {
          issues.push({
            file: configFile,
            severity: 'medium',
            message: 'Webpack devtool uses eval, which can be insecure in production',
          });
        }
      }
    });

    // Count issues by severity
    const vulns = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
    };

    issues.forEach(issue => {
      if (issue.severity === 'critical') vulns.critical++;
      else if (issue.severity === 'high') vulns.high++;
      else if (issue.severity === 'medium') vulns.medium++;
      else if (issue.severity === 'low') vulns.low++;
      else vulns.info++;
    });

    // Update summary
    updateSummary(vulns);

    // Store results
    results.scans.configCheck = {
      vulnerabilities: vulns,
      details: issues,
    };

    // Display results
    if (vulns.high > 0) {
      console.log(chalk.red(`Found ${vulns.high} high severity configuration issues`));
    } else if (vulns.medium > 0) {
      console.log(chalk.yellow(`Found ${vulns.medium} medium severity configuration issues`));
    } else {
      console.log(chalk.green('Configuration check completed with no high severity issues'));
    }
  } catch (error) {
    console.log(chalk.red(`Error checking configurations: ${error.message}`));
    results.scans.configCheck = {
      error: error.message,
    };
  }
};

/**
 * Scan for hardcoded secrets
 */
const scanForSecrets = async () => {
  console.log(chalk.blue('Scanning for hardcoded secrets...'));

  try {
    const secretsFound = [];

    // Use custom secret scanning
    const secretPatterns = [
      {
        pattern: /(['"])(?:api|access)[-_]?key['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/,
        name: 'API Key',
      },
      {
        pattern: /(['"])(?:secret|private)[-_]?key['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/,
        name: 'Secret Key',
      },
      { pattern: /(['"])password['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/, name: 'Password' },
      { pattern: /(['"])token['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/, name: 'Token' },
      {
        pattern: /(['"])auth(?:entication)?['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/,
        name: 'Authentication',
      },
      {
        pattern:
          /(['"])(?:aws|firebase|stripe|twilio)[-_]?(?:key|token|secret)['"]?\s*[:=]\s*['"]([^'"]{8,})['"]/,
        name: 'Service Credentials',
      },
    ];

    // Get all files
    const getAllFiles = (dir, fileList = []) => {
      const files = fs.readdirSync(dir);

      files.forEach(file => {
        const filePath = path.join(dir, file);

        if (fs.statSync(filePath).isDirectory()) {
          // Skip node_modules and .git directories
          if (file !== 'node_modules' && file !== '.git') {
            getAllFiles(filePath, fileList);
          }
        } else {
          // Skip binary files and specific extensions
          const ext = path.extname(file).toLowerCase();
          const skipExts = [
            '.jpg',
            '.jpeg',
            '.png',
            '.gif',
            '.svg',
            '.ico',
            '.woff',
            '.woff2',
            '.ttf',
            '.eot',
            '.mp3',
            '.mp4',
            '.webm',
            '.pdf',
          ];

          if (!skipExts.includes(ext)) {
            fileList.push(filePath);
          }
        }
      });

      return fileList;
    };

    const files = getAllFiles('.');

    // Scan each file
    files.forEach(file => {
      try {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.split('\n');

        lines.forEach((line, i) => {
          secretPatterns.forEach(({ pattern, name }) => {
            const match = line.match(pattern);
            if (match) {
              secretsFound.push({
                file,
                line: i + 1,
                secret: `${name}: ${match[0]}`,
                severity: 'high',
              });
            }
          });
        });
      } catch (error) {
        // Skip files that can't be read as text
      }
    });

    // Count secrets by severity
    const vulns = {
      critical: 0,
      high: secretsFound.length,
      medium: 0,
      low: 0,
      info: 0,
    };

    // Update summary
    updateSummary(vulns);

    // Store results
    results.scans.secretScan = {
      vulnerabilities: vulns,
      details: secretsFound,
    };

    // Display results
    if (vulns.high > 0) {
      console.log(chalk.red(`Found ${vulns.high} potential hardcoded secrets`));
    } else {
      console.log(chalk.green('No hardcoded secrets found'));
    }
  } catch (error) {
    console.log(chalk.red(`Error scanning for secrets: ${error.message}`));
    results.scans.secretScan = {
      error: error.message,
    };
  }
};

/**
 * Save scan results to file
 */
const saveResults = () => {
  try {
    fs.writeFileSync('vulnerability-scan-results.json', JSON.stringify(results, null, 2));
    console.log(chalk.green(`\nScan results saved to vulnerability-scan-results.json`));
  } catch (error) {
    console.error(chalk.red(`Error saving results: ${error.message}`));
  }
};

/**
 * Display summary of scan results
 */
const displaySummary = () => {
  console.log('\n' + chalk.bold('Vulnerability Scan Summary:'));
  console.log(chalk.red(`Critical: ${results.summary.critical}`));
  console.log(chalk.red(`High: ${results.summary.high}`));
  console.log(chalk.yellow(`Medium: ${results.summary.medium}`));
  console.log(chalk.blue(`Low: ${results.summary.low}`));
  console.log(chalk.gray(`Info: ${results.summary.info}`));
  console.log(chalk.bold(`Total: ${results.summary.total}`));
};

/**
 * Main function
 */
const main = async () => {
  console.log(chalk.bold('\nAI Sports Edge Vulnerability Scanner'));
  console.log(chalk.bold('=====================================\n'));

  // Run npm audit
  await runNpmAudit();

  // Check for insecure configurations
  await checkInsecureConfigs();

  // Scan for hardcoded secrets
  await scanForSecrets();

  // Display summary
  displaySummary();

  // Save results
  saveResults();

  // Exit with appropriate code
  if (results.summary.critical > 0 || results.summary.high > 0) {
    process.exit(1);
  } else {
    process.exit(0);
  }
};

// Run the main function
main().catch(error => {
  console.error(chalk.red(`Error running vulnerability scan: ${error.message}`));
  process.exit(1);
});
